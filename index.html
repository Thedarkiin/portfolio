<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Portfolio | Yassin Asermouh</title>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "gsap": "https://unpkg.com/gsap@3.12.5/index.js"
            }
        }
    </script>

    <style>
        /* FONTS */
        @import url('https://fonts.googleapis.com/css2?family=Montserrat:wght@300;500;700&family=Lato:wght@300;400&display=swap');

        body, html {
            margin: 0; overflow: hidden; background-color: #000a12;
            font-family: 'Lato', sans-serif; color: #e0e0e0; cursor: default;
            transition: background-color 3s ease; user-select: none;
        }

        #ui-layer { position: fixed; inset: 0; z-index: 10; pointer-events: none; }

        /* LOADER */
        #loader {
            position: fixed; inset: 0; background: #020406; z-index: 300;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            font-family: 'Montserrat', sans-serif;
        }
        .loader-ring {
            width: 80px; height: 80px; border: 2px solid rgba(197, 160, 89, 0.1);
            border-top: 2px solid #c5a059; border-radius: 50%;
            animation: spin 1.5s cubic-bezier(0.68, -0.55, 0.27, 1.55) infinite; margin-bottom: 30px;
            box-shadow: 0 0 20px rgba(197, 160, 89, 0.1);
        }
        .loader-text {
            color: #c5a059; letter-spacing: 8px; font-size: 0.9rem;
            animation: pulse 2s infinite; text-transform: uppercase;
        }
        #load-bar-container {
            width: 250px; height: 3px; background: #1a1a1a; margin-top: 20px; 
            border-radius: 4px; overflow: hidden; position: relative;
        }
        #load-fill {
            width: 0%; height: 100%; background: #c5a059; 
            box-shadow: 0 0 10px #c5a059; transition: width 0.1s linear;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        @keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }

        /* INTRO */
        #intro-screen {
            position: fixed; inset: 0; background: rgba(2, 4, 6, 0.95); z-index: 200;
            display: flex; justify-content: center; align-items: center;
            pointer-events: auto; transition: opacity 1.5s ease-out;
            backdrop-filter: blur(20px);
        }
        #start-btn {
            padding: 20px 60px; background: transparent; 
            border: 1px solid rgba(197, 160, 89, 0.5);
            color: #c5a059; font-family: 'Montserrat', sans-serif; font-weight: 700;
            font-size: 1.2rem; letter-spacing: 4px;
            cursor: pointer; transition: 0.4s; text-transform: uppercase;
            position: relative; overflow: hidden;
        }
        #start-btn::before {
            content: ''; position: absolute; top: 0; left: -100%; width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(197, 160, 89, 0.2), transparent);
            transition: 0.5s;
        }
        #start-btn:hover { border-color: #ffd700; color: #ffd700; box-shadow: 0 0 30px rgba(197, 160, 89, 0.2); }
        #start-btn:hover::before { left: 100%; }

        /* CONTROLS */
        .controls { 
            position: absolute; top: 30px; left: 30px; 
            display: flex; gap: 15px; pointer-events: auto; 
        }
        .btn-icon {
            width: 44px; height: 44px; border-radius: 8px; background: rgba(5, 10, 15, 0.6);
            border: 1px solid rgba(255,255,255,0.1); color: #8a9bb0; font-size: 1.1rem;
            display: flex; justify-content: center; align-items: center; cursor: pointer;
            backdrop-filter: blur(5px); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        .btn-icon:hover, .btn-icon.active { background: rgba(197, 160, 89, 0.1); color: #ffd700; border-color: #ffd700; }

        /* VOLUME SLIDER */
        .volume-container {
            display: flex; align-items: center; gap: 10px;
            background: rgba(5, 10, 15, 0.6); padding: 10px 15px; border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1); backdrop-filter: blur(5px);
        }
        input[type=range] {
            -webkit-appearance: none; width: 100px; height: 4px; background: rgba(255,255,255,0.2);
            border-radius: 2px; outline: none;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; width: 12px; height: 12px; border-radius: 50%;
            background: #c5a059; cursor: pointer; transition: 0.2s;
        }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.2); background: #ffd700; }

        /* WEATHER WIDGET */
        #weather-widget {
            position: absolute; top: 30px; right: 30px;
            padding: 12px 24px; background: rgba(5, 10, 15, 0.4);
            border-left: 3px solid #c5a059; border-radius: 2px;
            font-family: 'Montserrat', monospace; color: #c5a059;
            backdrop-filter: blur(8px); text-transform: uppercase;
            font-size: 0.8rem; letter-spacing: 1px; font-weight: 500;
            box-shadow: 0 0 20px rgba(0,0,0,0.3);
            display: flex; flex-direction: column; gap: 4px;
            transition: all 0.5s ease;
        }
        #weather-widget span { font-size: 0.7rem; color: #8a9bb0; letter-spacing: 1px; }

        /* HUD */
        .hud-action {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            font-family: 'Montserrat', sans-serif; font-size: 0.8rem; color: rgba(255,255,255,0.6);
            border: 1px solid rgba(255,255,255,0.1); padding: 8px 20px; border-radius: 4px;
            pointer-events: none; letter-spacing: 2px; text-transform: uppercase;
            background: rgba(0,0,0,0.3); backdrop-filter: blur(4px);
        }

        /* MINIMAP */
        #minimap-container {
            position: absolute; bottom: 30px; right: 30px; width: 180px; height: 180px;
            pointer-events: auto; transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.3s;
            opacity: 1;
        }
        #minimap-container.hidden { transform: translateY(20px) scale(0.9); opacity: 0; pointer-events: none; }
        
        #minimap {
            width: 100%; height: 100%; border-radius: 50%; 
            border: 2px solid rgba(197, 160, 89, 0.3); overflow: hidden;
            background: radial-gradient(circle, #0b151d 0%, #000000 100%);
            box-shadow: 0 0 30px rgba(0,0,0,0.5); relative;
        }
        #minimap::after {
            content: ''; position: absolute; inset: 0; border-radius: 50%;
            background: repeating-linear-gradient(0deg, transparent 0, transparent 19px, rgba(197, 160, 89, 0.1) 20px);
            pointer-events: none;
        }
        #minimap-arrow {
            position: absolute; top: 50%; left: 50%; width: 12px; height: 12px;
            background: #ff4444; border: 2px solid #fff; border-radius: 50%;
            transform: translate(-50%, -50%); z-index: 55;
            box-shadow: 0 0 10px #ff4444;
        }

        /* INTERACTION */
        .interact-prompt {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            display: none; flex-direction: column; align-items: center; gap: 8px;
            pointer-events: none;
        }
        .interact-key {
            width: 30px; height: 30px; border: 1px solid #ffd700; color: #ffd700;
            display: flex; align-items: center; justify-content: center;
            font-family: 'Montserrat', sans-serif; font-weight: bold; border-radius: 4px;
            background: rgba(0,0,0,0.5); box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
            animation: bounce 1s infinite alternate;
        }
        .interact-label {
            color: #ffd700; font-family: 'Montserrat', sans-serif; font-size: 0.8rem; letter-spacing: 2px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        @keyframes bounce { from{transform:translateY(0)} to{transform:translateY(-5px)} }

        /* RPG DIALOGUE */
        #rpg-ui {
            position: absolute; bottom: 50px; left: 50%; transform: translateX(-50%) translateY(20px);
            width: 90%; max-width: 650px; background: rgba(5, 8, 12, 0.95);
            border: 1px solid rgba(74, 90, 106, 0.5); border-radius: 4px; 
            box-shadow: 0 20px 60px rgba(0,0,0,0.9); display: none; opacity: 0;
            transition: 0.5s; pointer-events: auto; z-index: 50; overflow: hidden;
            backdrop-filter: blur(10px);
        }
        #rpg-ui.active { display: block; opacity: 1; transform: translateX(-50%) translateY(0); }
        
        .rpg-inner { display: flex; padding: 25px; gap: 20px; align-items: flex-start; }
        .rpg-portrait {
            width: 70px; height: 70px; background: #0b1015; border: 1px solid #c5a059;
            display: flex; justify-content: center; align-items: center; font-size: 2.2rem;
            box-shadow: inset 0 0 20px rgba(197, 160, 89, 0.1); flex-shrink: 0;
        }
        .rpg-name { color: #c5a059; font-family: 'Montserrat', sans-serif; font-size: 0.9rem; margin-bottom: 8px; letter-spacing: 2px; text-transform: uppercase; font-weight: 700; }
        .rpg-text { color: #d0d0d0; font-size: 1.05rem; line-height: 1.8; font-family: 'Lato', sans-serif; }
        .rpg-choices { 
            background: rgba(0,0,0,0.3); padding: 15px 25px; display: flex; 
            gap: 15px; justify-content: flex-end; border-top: 1px solid rgba(255,255,255,0.05);
        }
        .rpg-btn {
            background: transparent; border: 1px solid rgba(170, 221, 255, 0.3); color: #aaddff;
            padding: 8px 18px; border-radius: 2px; cursor: pointer; font-family: 'Montserrat', sans-serif;
            font-size: 0.8rem; transition: 0.2s; text-transform: uppercase; letter-spacing: 1px; font-weight: 500;
        }
        .rpg-btn:hover { background: rgba(170, 221, 255, 0.1); color: #fff; border-color: #fff; }

        /* PORTFOLIO */
        #portfolio-modal {
            position: fixed; inset: 0; background: rgba(0,0,0,0.9);
            backdrop-filter: blur(15px); z-index: 100; display: flex;
            justify-content: center; align-items: center; opacity: 0;
            pointer-events: none; transition: opacity 0.6s ease;
        }
        #portfolio-modal.active { opacity: 1; pointer-events: auto; }

        .glass-card {
            width: 85vw; max-width: 1000px; height: 80vh; 
            background: #0f1215;
            border: 1px solid rgba(255,255,255,0.08); border-radius: 12px; 
            display: grid; grid-template-columns: 240px 1fr; 
            overflow: hidden; position: relative;
            box-shadow: 0 0 100px rgba(0,0,0,0.9);
        }
        
        .p-sidebar {
            background: #0a0c0e; border-right: 1px solid rgba(255,255,255,0.05);
            padding: 40px 20px; display: flex; flex-direction: column; gap: 8px;
        }
        .p-nav-header {
            color: #4a5a6a; margin-bottom: 20px; font-size: 0.7rem; 
            letter-spacing: 3px; font-weight: bold; padding-left: 15px; font-family: 'Montserrat', sans-serif;
        }
        .p-nav {
            padding: 12px 15px; color: #8a9bb0; cursor: pointer; font-family: 'Montserrat', sans-serif; 
            font-size: 0.9rem; transition: 0.3s; letter-spacing: 1px; border-radius: 6px; font-weight: 500;
        }
        .p-nav:hover { background: rgba(255,255,255,0.03); color: #e0e0e0; }
        .p-nav.active { background: rgba(197, 160, 89, 0.1); color: #ffd700; border-left: 3px solid #ffd700; }

        .p-content { padding: 50px 60px; overflow-y: auto; color: #bfbfbf; position: relative; }
        
        .section { display: none; animation: blurFadeIn 0.8s cubic-bezier(0.16, 1, 0.3, 1); }
        .section.active { display: block; }
        @keyframes blurFadeIn { from { opacity: 0; transform: translateY(20px); filter: blur(10px); } to { opacity: 1; transform: translateY(0); filter: blur(0px); } }

        h2 { font-family: 'Montserrat', sans-serif; color: #fff; font-size: 2.5rem; margin: 0 0 10px 0; letter-spacing: -0.5px; font-weight: 700; }
        .subtitle { font-family: 'Montserrat', sans-serif; color: #c5a059; font-size: 0.85rem; margin-bottom: 40px; display: block; letter-spacing: 2px; font-weight: 500; }
        p { line-height: 1.8; font-size: 1.05rem; color: #a0aab5; margin-bottom: 20px; font-family: 'Lato', sans-serif; }
        strong { color: #fff; font-weight: 700; }

        .data-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 20px; margin-top: 30px; }
        .data-card {
            background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.05);
            padding: 25px; border-radius: 8px; transition: 0.3s;
        }
        .data-card:hover { 
            background: rgba(255,255,255,0.04); border-color: rgba(197, 160, 89, 0.3); 
            transform: translateY(-5px); box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        .data-card h3 { 
            font-family: 'Montserrat', sans-serif; font-size: 1.1rem; color: #e0e0e0; margin: 0 0 10px 0; 
            border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; font-weight: 600;
        }
        .data-card p { font-size: 0.95rem; margin: 0; }

        .resume-btn {
            display: inline-block; padding: 12px 30px; 
            background: #c5a059; color: #000; 
            font-family: 'Montserrat', sans-serif; font-weight: 700; font-size: 0.9rem;
            text-decoration: none; border-radius: 4px; letter-spacing: 1px;
            transition: 0.3s; margin-top: 20px;
        }
        .resume-btn:hover { background: #fff; transform: translateY(-2px); box-shadow: 0 5px 20px rgba(197, 160, 89, 0.3); }

        .close-x-btn { 
            position: absolute; top: 20px; right: 20px; 
            width: 40px; height: 40px; z-index: 101;
            display: flex; justify-content: center; align-items: center;
            color: #666; cursor: pointer; font-size: 1.2rem; transition:0.3s; 
            font-family: 'Montserrat', sans-serif; border-radius: 50%;
        }
        .close-x-btn:hover { color: #fff; background: rgba(255,255,255,0.1); transform: rotate(90deg); }

        @media (max-width: 800px) {
            .glass-card { grid-template-columns: 1fr; height: 90vh; }
            .p-sidebar { flex-direction: row; padding: 15px; border-right: none; border-bottom: 1px solid rgba(255,255,255,0.1); overflow-x: auto; }
            .p-content { padding: 30px; }
        }
    </style>
</head>
<body>

    <!-- LOADER -->
    <div id="loader">
        <div class="loader-ring"></div>
        <div class="loader-text">LOADING ASSETS...</div>
        <div id="load-bar-container"><div id="load-fill"></div></div>
    </div>

    <!-- INTRO -->
    <div id="intro-screen">
        <button id="start-btn">SET SAIL</button>
    </div>

    <div id="ui-layer">
        <div class="controls">
            <div class="control-row">
                <div class="btn-icon" id="theme-btn" title="Toggle Cycle">‚òÄÔ∏è</div>
                <!-- VOLUME SLIDER -->
                <div class="volume-container">
                    <i class="btn-icon" style="font-size: 0.9rem; width:20px; height:20px; background:none; border:none;">üéµ</i>
                    <input type="range" id="volume-slider" min="0" max="100" value="5">
                </div>
            </div>
        </div>
        
        <div id="weather-widget">
            <div id="ww-status">STATUS: SUNRISE</div>
            <span id="ww-temp">TEMP: 14¬∞C</span>
        </div>

        <div class="hud-action">[SPACE] FIRE CANNON</div>

        <div class="interact-prompt" id="npc-prompt">
            <div class="interact-key">E</div>
            <div class="interact-label">INTERACT</div>
        </div>
        
        <div id="minimap-container">
            <div id="minimap"></div>
            <div id="minimap-arrow"></div>
        </div>
    </div>

    <!-- RPG UI -->
    <div id="rpg-ui">
        <div class="rpg-inner">
            <div class="rpg-portrait">üëí</div>
            <div class="rpg-main">
                <div class="rpg-name">Monkey D. Luffy</div>
                <div class="rpg-text" id="rpg-text"></div>
            </div>
        </div>
        <div class="rpg-choices" id="rpg-options"></div>
    </div>

    <!-- PORTFOLIO -->
    <div id="portfolio-modal">
        <div class="glass-card">
            <div class="close-x-btn" onclick="Game.closePortfolio()" title="Close">‚úï</div>
            
            <div class="p-sidebar">
                <div class="p-nav-header">MENU</div>
                <div class="p-nav active" onclick="Game.nav('about')">About Me</div>
                <div class="p-nav" onclick="Game.nav('resume')">Resume</div>
                <div class="p-nav" onclick="Game.nav('contact')">Contact</div>
            </div>
            
            <div class="p-content">
                <div id="sec-about" class="section active"></div>
                <div id="sec-resume" class="section"></div>
                <div id="sec-contact" class="section"></div>
            </div>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { Water } from 'three/addons/objects/Water.js';
        import { Sky } from 'three/addons/objects/Sky.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import gsap from 'gsap';

        const CONFIG = {
            day: {
                ambient: 0.7,
                dirIntensity: 1.8,
                sunColor: 0xffaa33, 
                fog: 0x8899aa, 
                fogDensity: 0.006, 
                sky: { elevation: 7, azimuth: 180 } 
            },
            night: {
                ambient: 0.1,
                dirIntensity: 0.2,
                sunColor: 0x6677aa,
                fog: 0x05070a,
                fogDensity: 0.015,
                sky: { elevation: -5, azimuth: 180 }
            }
        };

        const CONTENT = {
            about: `
                <h2>Yassin Asermouh</h2>
                <span class="subtitle">DATA SCIENCE STUDENT @ INSEA</span>
                <br>
                <p>I am a Data Science student at the <strong>National Institute of Statistics and Applied Economics (INSEA)</strong>, driven by a deep curiosity for learning.</p>
                <p>My academic focus is on Statistical Learning, Deep Learning and Mathematical modeling.</p>
                
                <div class="data-grid">
                    <div class="data-card"><h3>Core interest</h3><p>Neuronal models, Deep Learning, Optimization.</p></div>
                </div>
            `,
            resume: `
                <h2>Professional Resume</h2>
                <span class="subtitle">EDUCATION & SKILLS</span>
                
                <div style="background: rgba(255,255,255,0.03); padding: 30px; border-radius: 8px; border-left: 3px solid #c5a059; margin-bottom: 30px;">
                    <h3 style="color: #fff; font-family: 'Montserrat'; margin-top: 0;">Education</h3>
                    <p style="margin-bottom: 5px;"><strong>State Engineer Degree (Data Science)</strong> | INSEA</p>
                    <p style="font-size: 0.9rem; color: #888;">Focus: Data Engineering, Machine Learning, Economics.</p>
                </div>

                <div class="data-grid">
                    <div class="data-card">
                        <h3>Data & ML</h3>
                        <p>Python, SQL,Docker, Scikit-Learn, Pytorch, Airflow, Pandas, NumPy.</p>
                    </div>
                    <div class="data-card">
                        <h3>Visualization & AI</h3>
                        <p>PowerBI, Prompt Engineering (LLMs), Generative AI Workflows.</p>
                    </div>
                </div>

                <br>
                <p>Download my full CV to see detailed project history in Finance and Data Science.</p>
                <a href="#" class="resume-btn">Download Full CV (PDF)</a>
            `,
            contact: `
                <h2>Contact Me</h2>
                <span class="subtitle">LET'S CONNECT</span>
                <p>I am open to opportunities in <strong>Data Science</strong>, <strong>Data&Ai Engineering</strong>, and <strong>Machine Learning</strong> roles.</p>
                
                <div style="margin-top:40px; padding:30px; border:1px solid rgba(255, 255, 255, 0.1); border-radius:8px; text-align:center; background: rgba(255,255,255,0.02);">
                    <a href="mailto:asermouyassing@gmail.com" style="color:#c5a059; font-size:1.3rem; text-decoration:none; font-family:'Montserrat', sans-serif; display:block; margin-bottom:10px; font-weight: 700;">asermouyassing@gmail.com</a>
                    <span style="color:#666; font-size:0.8rem; letter-spacing:2px;">OFFICIAL EMAIL</span>
                </div>
                <div class="data-grid">
                    <div class="data-card" style="text-align:center; cursor:pointer;" onclick="window.open('https://www.linkedin.com/in/yassin-asermouh-984aa8249/', '_blank')">
                        <h3>LinkedIn</h3>
                        <p>View Profile ‚Üó</p>
                    </div>
                    <div class="data-card" style="text-align:center; cursor:pointer;" onclick="window.open('https://github.com/Thedarkiin', '_blank')">
                        <h3>GitHub</h3>
                        <p>View Repos ‚Üó</p>
                    </div>
                </div>
            `
        };

        // --- AUDIO ENGINE (Slider Version) ---
        class AudioEngine {
            constructor() {
                this.ctx = null;
                this.gainNode = null;
                this.audioElement = null;
                this.isMuted = true;
            }

            init() {
                if(this.ctx) return;
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
                this.gainNode = this.ctx.createGain();
                this.gainNode.gain.value = 0.05; 
                this.gainNode.connect(this.ctx.destination);

                this.audioElement = new Audio('music.mp3'); 
                this.audioElement.loop = true; 
                this.audioElement.crossOrigin = "anonymous";

                const track = this.ctx.createMediaElementSource(this.audioElement);
                track.connect(this.gainNode);

                this.audioElement.play().catch(e => console.log("Audio wait for interaction"));
            }

            setVolume(val) {
                if(this.ctx) {
                    const v = val / 100;
                    this.gainNode.gain.setTargetAtTime(v, this.ctx.currentTime, 0.1);
                    if(this.ctx.state === 'suspended') this.ctx.resume();
                }
            }
        }

        const Game = {
            scene: null, camera: null, renderer: null, controls: null,
            water: null, sky: null, sun: null,
            objects: { boat: null, npc: null, fireflies: null, birds: null, moon: null, lanterns: null, whale: null, pirateShips: [], hawk: null, supplyCrates: [], explosions: [], lightningBolts: [] },
            lights: { dir: null, amb: null },
            state: { night: false, docked: false, talking: false, mapVisible: true, canTalk: false, keys: {w:0,a:0,s:0,d:0}, whaleState: { t: 0, jumping: false }, lightningState: { timer: 0 } },
            physics: { speed: 0, angle: Math.PI, vel: new THREE.Vector3(), accel: 0.015, fric: 0.98, turn: 0.02, max: 0.8 },
            audio: new AudioEngine(),
            minimap: { renderer:null, scene:null, camera:null },

            init: function() {
                document.getElementById('sec-about').innerHTML = CONTENT.about;
                document.getElementById('sec-resume').innerHTML = CONTENT.resume;
                document.getElementById('sec-contact').innerHTML = CONTENT.contact;
                
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                document.getElementById('canvas-container').appendChild(this.renderer.domElement);

                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x001e28);
                this.scene.fog = new THREE.FogExp2(0x001e28, 0.005);

                this.camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 1, 20000);
                this.camera.position.set(0, 20, 40);

                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enablePan = false;
                this.controls.enableDamping = true;
                this.controls.minDistance = 20;
                this.controls.maxDistance = 80;
                this.controls.maxPolarAngle = Math.PI/2 - 0.05;

                this.buildWorld();
                this.buildMinimap();
                this.bindEvents();

                let p=0;
                const int = setInterval(()=>{
                    p+=2; document.getElementById('load-fill').style.width=p+'%';
                    if(p>=100) {
                        clearInterval(int);
                        gsap.to('#loader', {opacity:0, duration:0.8, onComplete:()=>document.getElementById('loader').remove()});
                    }
                },20);

                window.Game = this;
                this.animate();
            },

            bindEvents: function() {
                window.addEventListener('resize', () => this.onResize());
                window.addEventListener('keydown', e => this.key(e, 1));
                window.addEventListener('keyup', e => this.key(e, 0));
                document.getElementById('start-btn').onclick = () => this.start();
                document.getElementById('theme-btn').onclick = () => this.toggleTheme();
                
                const slider = document.getElementById('volume-slider');
                slider.oninput = (e) => this.audio.setVolume(e.target.value);
                // FIX: Remove focus when mouse is released to prevent arrow keys from changing volume
                slider.onchange = (e) => e.target.blur();
                slider.addEventListener('mouseup', function() { this.blur(); });
            },

            key: function(e, v) {
                const k = e.key.toLowerCase();
                if(k==='w'||k==='arrowup') this.state.keys.w=v;
                if(k==='s'||k==='arrowdown') this.state.keys.s=v;
                if(k==='a'||k==='arrowleft') this.state.keys.a=v;
                if(k==='d'||k==='arrowright') this.state.keys.d=v;
                
                if(v && k===' ') this.shoot();
                if(v && k==='e' && this.state.canTalk && !this.state.talking) this.startDialogue();
            },

            start: function() {
                gsap.to('#intro-screen', {opacity:0, duration:1, onComplete:()=>{
                    document.getElementById('intro-screen').style.display='none';
                    this.audio.init();
                }});
            },

            buildWorld: function() {
                this.lights.amb = new THREE.AmbientLight(0xffffff, CONFIG.day.ambient);
                this.scene.add(this.lights.amb);
                this.lights.dir = new THREE.DirectionalLight(CONFIG.day.sunColor, CONFIG.day.dirIntensity);
                this.lights.dir.position.set(100, 50, -50);
                this.lights.dir.castShadow = true;
                this.lights.dir.shadow.mapSize.set(2048,2048);
                this.scene.add(this.lights.dir);

                const wGeo = new THREE.PlaneGeometry(10000,10000);
                this.water = new Water(wGeo, {
                    textureWidth: 512, textureHeight: 512,
                    waterNormals: new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/master/examples/textures/waternormals.jpg', t => t.wrapS=t.wrapT=THREE.RepeatWrapping),
                    sunDirection: this.lights.dir.position.clone().normalize(),
                    sunColor: CONFIG.day.sunColor, waterColor: 0x001e0f, distortionScale: 3.7, fog: true
                });
                this.water.rotation.x = -Math.PI/2;
                this.scene.add(this.water);

                this.sky = new Sky();
                this.sky.scale.setScalar(10000);
                this.sky.material.uniforms.turbidity.value = 10;
                this.sky.material.uniforms.rayleigh.value = 3;
                this.sky.material.uniforms.mieCoefficient.value = 0.005;
                this.sky.material.uniforms.mieDirectionalG.value = 0.7;
                this.scene.add(this.sky);
                this.sun = new THREE.Vector3();
                this.updateSky(CONFIG.day.sky.elevation); 

                this.buildIsland();
                this.buildBoat();
                this.buildWhale(); 
                this.buildHugePirateShip(120, -120); 
                this.buildHugePirateShip(-150, 80);
                this.buildEffects();
                this.buildLanterns();
                this.buildCrates(); 
            },

            updateSky: function(elevation) {
                const phi = THREE.MathUtils.degToRad(90 - elevation);
                const theta = THREE.MathUtils.degToRad(180);
                this.sun.setFromSphericalCoords(1, phi, theta);
                this.sky.material.uniforms.sunPosition.value.copy(this.sun);
                this.water.material.uniforms.sunDirection.value.copy(this.sun).normalize();
                this.scene.environment = new THREE.PMREMGenerator(this.renderer).fromScene(this.sky).texture;
            },

            triggerLightning: function() {
                const flashColor = new THREE.Color(0xffffff);
                const nightFog = new THREE.Color(0x05070a);
                this.scene.background = flashColor;
                this.scene.fog.color = flashColor;
                const originalIntensity = this.lights.amb.intensity;
                this.lights.amb.intensity = 2.0;
                setTimeout(() => {
                    this.scene.background = nightFog;
                    this.scene.fog.color = nightFog;
                    this.lights.amb.intensity = originalIntensity;
                }, 100);

                const start = new THREE.Vector3((Math.random()-0.5)*300, 100, (Math.random()-0.5)*300);
                const end = new THREE.Vector3(start.x + (Math.random()-0.5)*20, 0, start.z + (Math.random()-0.5)*20);
                const points = [];
                let current = start.clone();
                points.push(current.clone());
                for(let i=0; i<15; i++) {
                    current.lerp(end, (i+1)/15);
                    if(i < 14) { current.x += (Math.random()-0.5)*10; current.z += (Math.random()-0.5)*10; }
                    points.push(current.clone());
                }
                const geo = new THREE.BufferGeometry().setFromPoints(points);
                const mat = new THREE.LineBasicMaterial({color: 0xaaddff, linewidth: 3});
                const bolt = new THREE.Line(geo, mat);
                this.scene.add(bolt);
                this.objects.lightningBolts.push({ mesh: bolt, age: 0 });
            },

            buildIsland: function() {
                const g = new THREE.Group();
                // SANDY SHORE RING (FIXED OVERLAP)
                const sandGeo = new THREE.RingGeometry(15, 28, 32); // Inner rad 15 overlaps rock (20)
                sandGeo.rotateX(-Math.PI/2);
                const sandMat = new THREE.MeshStandardMaterial({color:0xe6c288, roughness:1}); 
                const sand = new THREE.Mesh(sandGeo, sandMat);
                sand.position.y = 0.2; 
                g.add(sand);

                // Rock Base
                const rockGeo = new THREE.CylinderGeometry(20, 25, 35, 32, 5); 
                rockGeo.translate(0, 10, 0);
                const pos = rockGeo.attributes.position;
                for(let i=0; i<pos.count; i++){
                    const x = pos.getX(i);
                    const y = pos.getY(i);
                    const z = pos.getZ(i);
                    if (y < 26) {
                        const noise = Math.sin(x*0.3) * Math.cos(z*0.3) * 2 + Math.sin(y*0.5)*1.5 + (Math.random()-0.5)*1.5;
                        const factor = 1 + (noise * 0.05);
                        pos.setX(i, x * factor);
                        pos.setZ(i, z * factor);
                    }
                }
                rockGeo.computeVertexNormals();
                const rock = new THREE.Mesh(rockGeo, new THREE.MeshStandardMaterial({color:0x2c2c2c, roughness:0.9, flatShading:true}));
                g.add(rock);

                const plat = new THREE.Mesh(new THREE.CylinderGeometry(21, 20, 4, 9), new THREE.MeshStandardMaterial({color:0x2d4c1e}));
                plat.position.y = 28; g.add(plat);

                const tower = new THREE.Group(); tower.position.y = 30;
                const base = new THREE.Mesh(new THREE.CylinderGeometry(6, 7, 15, 8), new THREE.MeshStandardMaterial({color:0x555, flatShading:true}));
                base.position.y = 7.5; tower.add(base);
                const mid = new THREE.Mesh(new THREE.CylinderGeometry(7, 6, 2, 8), new THREE.MeshStandardMaterial({color:0x333}));
                mid.position.y = 15; tower.add(mid);
                const roof = new THREE.Mesh(new THREE.ConeGeometry(8, 12, 8), new THREE.MeshStandardMaterial({color:0x223344}));
                roof.position.y = 22; tower.add(roof);
                const win = new THREE.Mesh(new THREE.PlaneGeometry(2, 4), new THREE.MeshBasicMaterial({color:0xffaa00}));
                win.position.set(0, 10, 6.5); tower.add(win);
                const twL = new THREE.PointLight(0xffaa00, 1, 40); twL.position.set(0, 10, 8); twL.name='houseLight'; tower.add(twL);
                g.add(tower);

                const dock = new THREE.Mesh(new THREE.BoxGeometry(8, 1, 30), new THREE.MeshStandardMaterial({color:0x4e342e}));
                dock.position.set(0, 2, 45); g.add(dock);

                // --- NPC: LUFFY (Stronger Geometry) ---
                const npc = new THREE.Group(); npc.position.set(0, 3.5, 52);
                
                // 1. Shorts (Blue)
                const shortsGeo = new THREE.CylinderGeometry(0.45, 0.5, 1.2, 8);
                const shortsMat = new THREE.MeshStandardMaterial({color: 0x0033aa});
                const shorts = new THREE.Mesh(shortsGeo, shortsMat);
                shorts.position.y = 0.6;
                npc.add(shorts);

                // 2. Torso / Red Vest (Broader shoulders)
                const chestGeo = new THREE.CylinderGeometry(0.65, 0.5, 1.4, 8);
                const vestMat = new THREE.MeshStandardMaterial({color: 0xff0000});
                const chest = new THREE.Mesh(chestGeo, vestMat);
                chest.position.y = 1.9;
                npc.add(chest);

                // 3. Arms (Skin color)
                const armGeo = new THREE.CylinderGeometry(0.15, 0.12, 1.4);
                const skinMat = new THREE.MeshStandardMaterial({color: 0xffe0bd});
                const lArm = new THREE.Mesh(armGeo, skinMat);
                lArm.position.set(0.75, 1.8, 0); lArm.rotation.z = -0.2;
                const rArm = new THREE.Mesh(armGeo, skinMat);
                rArm.position.set(-0.75, 1.8, 0); rArm.rotation.z = 0.2;
                npc.add(lArm); npc.add(rArm);

                // 4. Head
                const head = new THREE.Mesh(new THREE.DodecahedronGeometry(0.55), skinMat);
                head.position.y = 3.0;
                npc.add(head);
                
                // 5. Hat
                const hat = new THREE.Group();
                const brim = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 0.1, 32), new THREE.MeshStandardMaterial({color: 0xeebb00}));
                const top = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.8, 1.0, 32), new THREE.MeshStandardMaterial({color: 0xeebb00}));
                top.position.y = 0.5;
                const band = new THREE.Mesh(new THREE.CylinderGeometry(0.82, 0.82, 0.3, 32), new THREE.MeshStandardMaterial({color: 0xff0000}));
                band.position.y = 0.3;
                
                hat.add(brim); hat.add(top); hat.add(band);
                hat.position.set(0, 3.4, 0); 
                hat.rotation.z = -0.2; 
                npc.add(hat);
                // -------------------

                const npcLight = new THREE.PointLight(0x00ffff, 1, 10);
                npcLight.position.set(0, 4, 0); npc.add(npcLight);
                this.objects.npc = npc;
                g.add(npc);
                
                this.buildHawkForTheGuardian(npc);

                for(let i=0; i<8; i++) {
                    const t = new THREE.Group();
                    t.add(new THREE.Mesh(new THREE.CylinderGeometry(0.2,0.5,6), new THREE.MeshStandardMaterial({color:0x3e2723})).translateY(3));
                    const can = new THREE.Mesh(new THREE.SphereGeometry(3,8,8,0,Math.PI*2,0,Math.PI/2), new THREE.MeshStandardMaterial({color:0x2e5a1c, side:2}));
                    can.position.y=5; can.scale.y=1.5; t.add(can);
                    const a=Math.random()*Math.PI*2, r=12+Math.random()*6;
                    t.position.set(Math.cos(a)*r, 30, Math.sin(a)*r); t.rotation.z = (Math.random()-0.5)*0.3;
                    g.add(t);
                }
                this.scene.add(g);
            },

            buildHawkForTheGuardian: function(parent) {
                const g = new THREE.Group();
                const body = new THREE.Mesh(new THREE.CapsuleGeometry(0.2, 0.6, 4, 8), new THREE.MeshStandardMaterial({color:0x5d4037}));
                body.rotation.x = Math.PI/2; g.add(body);
                const wingGeo = new THREE.BoxGeometry(0.8, 0.05, 0.4);
                const lWing = new THREE.Mesh(wingGeo, new THREE.MeshStandardMaterial({color:0x8d6e63}));
                lWing.position.set(0.5, 0, 0); lWing.name="lw";
                const rWing = new THREE.Mesh(wingGeo, new THREE.MeshStandardMaterial({color:0x8d6e63}));
                rWing.position.set(-0.5, 0, 0); rWing.name="rw";
                g.add(lWing); g.add(rWing);
                const tail = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.5, 3), new THREE.MeshStandardMaterial({color:0x3e2723}));
                tail.rotation.x = -Math.PI/2; tail.position.z = 0.5; g.add(tail);
                g.position.set(0, 12, 0); g.scale.setScalar(1.0); 
                this.objects.hawk = g;
                parent.add(g);
            },

            animateHawk: function(t) {
                if(!this.objects.hawk) return;
                this.objects.hawk.position.x = Math.sin(t*2) * 5; 
                this.objects.hawk.position.z = Math.cos(t*2) * 5;
                this.objects.hawk.rotation.y = -t*2;
                const lw = this.objects.hawk.getObjectByName("lw");
                const rw = this.objects.hawk.getObjectByName("rw");
                if(lw && rw) { const flap = Math.sin(t*15) * 0.5; lw.rotation.z = flap; rw.rotation.z = -flap; }
            },

            buildHugePirateShip: function(x, z) {
                const g = new THREE.Group();
                const woodMat = new THREE.MeshStandardMaterial({color:0x3e2723, roughness:0.9});
                const hullBase = new THREE.Mesh(new THREE.CylinderGeometry(2, 4, 18, 8), woodMat);
                hullBase.rotation.x = Math.PI/2; hullBase.scale.z = 0.6; hullBase.position.y = 1.5; g.add(hullBase);
                const deck = new THREE.Mesh(new THREE.BoxGeometry(5, 3, 20), woodMat); deck.position.y = 2.5; g.add(deck);
                const poopDeck = new THREE.Mesh(new THREE.BoxGeometry(5, 3, 6), woodMat); poopDeck.position.set(0, 4, -6); g.add(poopDeck);
                const foreDeck = new THREE.Mesh(new THREE.BoxGeometry(5, 1.5, 4), woodMat); foreDeck.position.set(0, 4, 7); g.add(foreDeck);
                const mastGeo = new THREE.CylinderGeometry(0.2, 0.3, 18);
                const mast1 = new THREE.Mesh(mastGeo, woodMat); mast1.position.set(0, 10, 5);
                const mast2 = new THREE.Mesh(mastGeo, woodMat); mast2.position.set(0, 12, 0); mast2.scale.y=1.2;
                const mast3 = new THREE.Mesh(mastGeo, woodMat); mast3.position.set(0, 10, -5);
                g.add(mast1); g.add(mast2); g.add(mast3);
                const sailMat = new THREE.MeshStandardMaterial({color:0x111111, side:THREE.DoubleSide});
                const sailGeo = new THREE.PlaneGeometry(6, 4);
                const s1 = new THREE.Mesh(sailGeo, sailMat); s1.position.set(0, 8, 5.2);
                const s2 = new THREE.Mesh(sailGeo, sailMat); s2.position.set(0, 12, 0.2); s2.scale.set(1.2,1.2,1);
                const s3 = new THREE.Mesh(sailGeo, sailMat); s3.position.set(0, 8, -4.8);
                g.add(s1); g.add(s2); g.add(s3);
                g.userData = { angle: Math.random() * Math.PI * 2, target: new THREE.Vector3(x, 0, z), patrolCenter: new THREE.Vector3(x, 0, z) };
                g.position.set(x, 0, z);
                this.objects.pirateShips.push(g);
                this.scene.add(g);
            },

            updatePirateShips: function(t) {
                if(!this.objects.pirateShips.length) return;
                this.objects.pirateShips.forEach(ship => {
                    const distToTarget = ship.position.distanceTo(ship.userData.target);
                    if(distToTarget < 10) {
                        const angle = Math.random() * Math.PI * 2;
                        const radius = 40 + Math.random() * 40;
                        ship.userData.target.set(ship.userData.patrolCenter.x + Math.cos(angle)*radius, 0, ship.userData.patrolCenter.z + Math.sin(angle)*radius);
                    }
                    let moveDir = new THREE.Vector3().subVectors(ship.userData.target, ship.position).normalize();
                    const distToIsland = ship.position.length(); 
                    if (distToIsland < 60) { const pushDir = ship.position.clone().normalize(); moveDir.add(pushDir.multiplyScalar(2.5)); }
                    const distToPlayer = ship.position.distanceTo(this.objects.boat.position);
                    if (distToPlayer < 25) { const avoidDir = new THREE.Vector3().subVectors(ship.position, this.objects.boat.position).normalize(); moveDir.add(avoidDir.multiplyScalar(3.0)); }
                    moveDir.normalize(); 
                    ship.position.add(moveDir.multiplyScalar(0.12)); 
                    const targetRot = Math.atan2(moveDir.x, moveDir.z);
                    let rotDiff = targetRot - ship.rotation.y;
                    while (rotDiff > Math.PI) rotDiff -= Math.PI * 2; while (rotDiff < -Math.PI) rotDiff += Math.PI * 2;
                    ship.rotation.y += rotDiff * 0.01; 
                    ship.position.y = Math.sin(t * 0.8 + ship.userData.angle) * 0.5;
                    ship.rotation.z = Math.cos(t * 0.5 + ship.userData.angle) * 0.05; 
                });
            },

            buildDolphins: function() {
                this.objects.dolphins = new THREE.Group();
                const dolphGeo = new THREE.CapsuleGeometry(0.5, 2, 4, 8);
                const dolphMat = new THREE.MeshStandardMaterial({color: 0x778899, roughness: 0.4});
                for(let i=0; i<5; i++) {
                    const d = new THREE.Mesh(dolphGeo, dolphMat);
                    d.rotation.x = Math.PI/2; d.position.set(i*2 - 5, -2, i*2); d.userData = { offset: i * 0.5 };
                    this.objects.dolphins.add(d);
                }
                this.scene.add(this.objects.dolphins);
            },

            animateDolphins: function(t) {
                if(!this.objects.dolphins) return;
                const targetPos = this.objects.boat.position.clone();
                const offset = new THREE.Vector3(15, 0, 15); 
                this.objects.dolphins.position.lerp(targetPos.add(offset), 0.02);
                this.objects.dolphins.children.forEach(d => {
                    const jump = Math.sin(t * 3 + d.userData.offset);
                    d.position.y = Math.max(-2, jump * 3 - 1); 
                    d.rotation.x = Math.PI/2 - (jump * 0.5); 
                });
                this.objects.dolphins.rotation.y = this.objects.boat.rotation.y;
            },

            buildWhale: function() {
                const g = new THREE.Group();
                const bodyGeo = new THREE.SphereGeometry(6, 32, 32);
                const pos = bodyGeo.attributes.position;
                for(let i=0; i<pos.count; i++){
                    const v = new THREE.Vector3();
                    v.fromBufferAttribute(pos, i);
                    v.z *= 3.5; 
                    if(v.z > 0) { const taper = Math.max(0.1, 1 - (v.z / 20)); v.x *= taper; v.y *= taper; }
                    if(v.z < -5) { v.y *= 0.8; v.x *= 0.9; }
                    pos.setXYZ(i, v.x, v.y, v.z);
                }
                bodyGeo.computeVertexNormals();
                const body = new THREE.Mesh(bodyGeo, new THREE.MeshStandardMaterial({ color:0x1a2b3c, roughness:0.15, metalness:0.1 }));
                g.add(body);
                const tailGeo = new THREE.BoxGeometry(12, 0.5, 4);
                const tail = new THREE.Mesh(tailGeo, new THREE.MeshStandardMaterial({color:0x1a2b3c, roughness:0.2}));
                tail.position.set(0, 0, 18); g.add(tail);
                const finGeo = new THREE.BoxGeometry(8, 0.5, 3);
                const lFin = new THREE.Mesh(finGeo, new THREE.MeshStandardMaterial({color:0x1a2b3c, roughness:0.2}));
                lFin.position.set(5, -2, -2); lFin.rotation.z = -0.5; lFin.rotation.y = 0.5;
                const rFin = new THREE.Mesh(finGeo, new THREE.MeshStandardMaterial({color:0x1a2b3c, roughness:0.2}));
                rFin.position.set(-5, -2, -2); rFin.rotation.z = 0.5; rFin.rotation.y = -0.5;
                g.add(lFin); g.add(rFin);
                g.scale.setScalar(1.5);
                this.objects.whale = g;
                this.objects.whale.position.set(0, -30, -100); 
                this.scene.add(g);
            },

            buildCrates: function() {
                const g = new THREE.Group();
                const geo = new THREE.BoxGeometry(2,2,2);
                const mat = new THREE.MeshStandardMaterial({color:0x8d6e63});
                for(let i=0; i<5; i++) {
                    const c = new THREE.Mesh(geo, mat);
                    c.position.set((Math.random()-0.5)*100, 0, (Math.random()-0.5)*100);
                    c.rotation.set(Math.random(), Math.random(), Math.random());
                    c.userData = { offset: Math.random()*10, rotSpeed: (Math.random()-0.5)*0.01 };
                    g.add(c);
                    this.objects.supplyCrates.push(c);
                }
                this.scene.add(g);
            },

            buildBoat: function() {
                const g = new THREE.Group();
                const shape = new THREE.Shape();
                shape.moveTo(0,0);
                shape.bezierCurveTo(2,0, 2,8, 0,10); 
                shape.bezierCurveTo(-2,8, -2,0, 0,0); 
                const geo = new THREE.ExtrudeGeometry(shape, {depth:2.5, bevelEnabled:true, bevelSize:0.2, bevelThickness:0.2});
                geo.rotateX(Math.PI/2); geo.translate(0, 1.5, -5);
                const hull = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({color:0x4e342e}));
                g.add(hull);
                const mast = new THREE.Mesh(new THREE.CylinderGeometry(0.15,0.2,10), new THREE.MeshStandardMaterial({color:0x3e2723}));
                mast.position.set(0, 5, 0); g.add(mast);
                const sailShape = new THREE.Shape();
                sailShape.moveTo(0,0); sailShape.lineTo(0,7); sailShape.lineTo(5,1); sailShape.lineTo(0,0);
                const sailGeo = new THREE.ExtrudeGeometry(sailShape, {depth:0.1, bevelEnabled:false});
                const sail = new THREE.Mesh(sailGeo, new THREE.MeshStandardMaterial({color:0xeeeeee, side:2}));
                sail.position.set(0, 2, 0.2); sail.rotation.y=Math.PI/2; g.add(sail);
                const texLoader = new THREE.TextureLoader();
                const flagTex = texLoader.load('jolly.jpg', function(t) {}, undefined, function(e) { console.warn("Flag texture missing? Check filename 'jolly.jpg'"); });
                const flagGeo = new THREE.PlaneGeometry(3, 2);
                const flagMat = new THREE.MeshStandardMaterial({ map: flagTex, transparent: true, side: THREE.DoubleSide, alphaTest: 0.5 });
                const flag = new THREE.Mesh(flagGeo, flagMat);
                flag.position.set(0, 9.5, 0); flag.rotation.y = Math.PI / 2; flag.name = "pirateFlag"; 
                flag.geometry.translate(1.5, 0, 0); g.add(flag);
                const cannon = new THREE.Mesh(new THREE.CylinderGeometry(0.3,0.4,1.5), new THREE.MeshStandardMaterial({color:0x111}));
                cannon.rotation.x = Math.PI/2; cannon.position.set(0, 2, 4); 
                this.objects.cannon = cannon; g.add(cannon);
                const bl = new THREE.PointLight(0xffaa00, 0, 15); bl.position.set(0, 4, -4); bl.name="boatLight";
                const lm = new THREE.Mesh(new THREE.DodecahedronGeometry(0.3), new THREE.MeshBasicMaterial({color:0xffd700}));
                lm.position.set(0, 4, -4); g.add(lm); g.add(bl);
                g.position.set(0,0,150); g.rotation.y = Math.PI;
                this.objects.boat = g;
                this.scene.add(g);
            },

            buildEffects: function() {
                const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
                const ctx = cvs.getContext('2d');
                const gr = ctx.createRadialGradient(16,16,0,16,16,16);
                gr.addColorStop(0,'rgba(255,200,0,1)'); gr.addColorStop(1,'rgba(255,200,0,0)');
                ctx.fillStyle=gr; ctx.fillRect(0,0,32,32);
                const tex = new THREE.CanvasTexture(cvs);
                const fGeo = new THREE.BufferGeometry();
                const fPos = new Float32Array(450); 
                for(let i=0; i<450; i++) fPos[i] = (Math.random()-0.5)*80;
                fGeo.setAttribute('position', new THREE.BufferAttribute(fPos, 3));
                const fMat = new THREE.PointsMaterial({color:0xffaa00, size:0.8, map:tex, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false});
                this.objects.fireflies = new THREE.Points(fGeo, fMat);
                this.scene.add(this.objects.fireflies);
                this.objects.birds = new THREE.Group();
                const bGeo = new THREE.BufferGeometry();
                bGeo.setAttribute('position', new THREE.Float32BufferAttribute([0,0,0, 0.5,0,0.5, -0.5,0,0.5], 3));
                for(let i=0; i<20; i++) {
                    const b = new THREE.Mesh(bGeo, new THREE.MeshBasicMaterial({color:0xffffff, side:2}));
                    b.position.set((Math.random()-0.5)*60, 50+Math.random()*15, (Math.random()-0.5)*60);
                    this.objects.birds.add(b);
                }
                this.scene.add(this.objects.birds);
                this.buildMoon(); // UPDATED MOON
            },

            buildMoon: function() {
                const moonGeo = new THREE.SphereGeometry(20, 32, 32);
                const moonMat = new THREE.MeshStandardMaterial({ color: 0xffffaa, emissive: 0x444433, emissiveIntensity: 0.2, roughness: 0.8 });
                this.objects.moon = new THREE.Mesh(moonGeo, moonMat);
                this.objects.moon.position.set(-100, 100, -150);
                this.objects.moon.visible = false;
                this.scene.add(this.objects.moon);
            },

            buildLanterns: function() {
                this.objects.lanterns = new THREE.Group();
                const geo = new THREE.CylinderGeometry(0.3, 0.3, 0.6, 8);
                const mat = new THREE.MeshStandardMaterial({color:0xff4422, emissive:0xff4400, emissiveIntensity:2});
                for(let i=0; i<25; i++) { 
                    const l = new THREE.Mesh(geo, mat);
                    const angle = Math.random() * Math.PI * 2;
                    const radius = 25 + Math.random() * 60;
                    l.position.set(Math.cos(angle)*radius, 0.5, Math.sin(angle)*radius);
                    const pl = new THREE.PointLight(0xffaa00, 1, 8);
                    pl.position.y = 0.5; l.add(pl);
                    l.userData = { offset: Math.random() * 100, speed: 0.5 + Math.random() * 0.5 };
                    this.objects.lanterns.add(l);
                }
                this.scene.add(this.objects.lanterns);
            },

            buildMinimap: function() {
                this.minimap.renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
                this.minimap.renderer.setSize(200, 200);
                this.minimap.renderer.setClearColor(0x000000, 0);
                document.getElementById('minimap').appendChild(this.minimap.renderer.domElement);

                this.minimap.camera = new THREE.OrthographicCamera(-120, 120, 120, -120, 1, 1000);
                this.minimap.camera.position.set(0, 100, 0);
                this.minimap.camera.lookAt(0, 0, 0);
                this.minimap.scene = new THREE.Scene();
                
                const grid = new THREE.GridHelper(300, 15, 0x5d4037, 0x333333);
                this.minimap.scene.add(grid);

                const islandDot = new THREE.Mesh(new THREE.CircleGeometry(25, 32), new THREE.MeshBasicMaterial({color: 0x2e5a1c}));
                this.minimap.scene.add(islandDot);
                const dockDot = new THREE.Mesh(new THREE.PlaneGeometry(10, 30), new THREE.MeshBasicMaterial({color: 0x4e342e}));
                dockDot.position.set(0,0,45);
                this.minimap.scene.add(dockDot);
            },

            launchFirework: function() {
                const x = (Math.random() - 0.5) * 200;
                const z = (Math.random() - 0.5) * 200;
                const targetY = 40 + Math.random() * 20;
                this.createExplosion(new THREE.Vector3(x, targetY, z));
            },

            shoot: function() {
                if(!this.objects.boat) return;
                const particle = new THREE.Mesh(new THREE.SphereGeometry(0.3), new THREE.MeshBasicMaterial({color:0xffaa00}));
                const startPos = this.objects.boat.localToWorld(new THREE.Vector3(0, 2, 5)); 
                particle.position.copy(startPos);
                this.scene.add(particle);
                const vel = new THREE.Vector3(0, 10, 20).applyAxisAngle(new THREE.Vector3(0,1,0), this.objects.boat.rotation.y).normalize().multiplyScalar(1.5);
                const anim = () => {
                    particle.position.add(vel);
                    vel.y -= 0.02; 
                    if(particle.position.y < 0) {
                        this.scene.remove(particle);
                        this.createExplosion(particle.position); 
                    } else {
                        requestAnimationFrame(anim);
                    }
                };
                anim();
            },

            createExplosion: function(pos) {
                const count = 50;
                const geo = new THREE.BufferGeometry();
                const positions = [];
                const velocities = [];
                const colors = [];
                const colorPalette = [new THREE.Color(0xff0000), new THREE.Color(0x00ff00), new THREE.Color(0x0000ff), new THREE.Color(0xffff00), new THREE.Color(0xff00ff)];
                for(let i=0; i<count; i++) {
                    positions.push(pos.x, pos.y, pos.z);
                    const speed = Math.random()*0.8 + 0.2;
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    velocities.push(Math.sin(phi)*Math.cos(theta)*speed, Math.sin(phi)*Math.sin(theta)*speed, Math.cos(phi)*speed);
                    const c = colorPalette[Math.floor(Math.random()*colorPalette.length)];
                    colors.push(c.r, c.g, c.b);
                }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                const mat = new THREE.PointsMaterial({ size: 1.2, vertexColors: true, transparent: true, blending: THREE.AdditiveBlending });
                const points = new THREE.Points(geo, mat);
                this.scene.add(points);
                this.objects.explosions.push({ mesh: points, vels: velocities, age: 0, gravity: 0.01, drag: 0.98 });
            },

            createSplash: function(pos) {
                const count = 30;
                const geo = new THREE.BufferGeometry();
                const positions = [];
                const velocities = [];
                for(let i=0; i<count; i++) {
                    positions.push(pos.x, 0.5, pos.z);
                    velocities.push((Math.random()-0.5)*2, Math.random()*3 + 1, (Math.random()-0.5)*2);
                }
                geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
                const mat = new THREE.PointsMaterial({ color: 0xffffff, size: 1.5, transparent: true, opacity: 0.8 });
                const points = new THREE.Points(geo, mat);
                this.scene.add(points);
                this.objects.explosions.push({ mesh: points, vels: velocities, age: 0, gravity: 0.1, drag: 0.95 });
            },

            toggleTheme: function() {
                this.state.night = !this.state.night;
                const t = this.state.night ? CONFIG.night : CONFIG.day;
                document.getElementById('theme-btn').innerText = this.state.night ? 'üåô' : '‚òÄÔ∏è';
                document.getElementById('ww-status').innerText = this.state.night ? 'STATUS: MIDNIGHT' : 'STATUS: SUNRISE';
                document.getElementById('ww-temp').innerText = this.state.night ? 'TEMP: 8¬∞C' : 'TEMP: 14¬∞C';
                const dur = 2;
                gsap.to(this.lights.amb, {intensity: t.ambient, duration: dur});
                gsap.to(this.lights.dir, {intensity: t.dirIntensity, duration: dur});
                const c = new THREE.Color(t.sunColor);
                gsap.to(this.lights.dir.color, {r:c.r, g:c.g, b:c.b, duration: dur});
                const f = new THREE.Color(t.fog);
                gsap.to(this.scene.fog.color, {r:f.r, g:f.g, b:f.b, duration: dur});
                gsap.to(this.scene.background, {r:f.r, g:f.g, b:f.b, duration: dur});
                gsap.to(this.scene.fog, {density: t.fogDensity, duration: dur});
                const bl = this.objects.boat.getObjectByName('boatLight');
                const hl = this.scene.getObjectByName('houseLight');
                if(bl) gsap.to(bl, {intensity: this.state.night?2:0, duration:1});
                if(hl) gsap.to(hl, {intensity: this.state.night?2:0, duration:1});
                if(this.objects.moon) this.objects.moon.visible = this.state.night;
                if(this.objects.birds) this.objects.birds.visible = !this.state.night;
                if(this.objects.fireflies) gsap.to(this.objects.fireflies.material, {opacity: this.state.night?1:0.2, duration:1});
                if(this.objects.lanterns) {
                    this.objects.lanterns.children.forEach(l => {
                        const pl = l.children[0];
                        gsap.to(l.material, {emissiveIntensity: this.state.night?2:0.5, duration:1});
                        if(pl) gsap.to(pl, {intensity: this.state.night?1.5:0.5, duration:1});
                    });
                }
                this.updateSky(t.sky.elevation, t.sky.azimuth);
            },

            updatePhysics: function() {
                if(this.state.docked || this.state.talking) return;
                const b = this.physics; const k = this.state.keys;
                if(k.w) b.speed += b.accel;
                if(k.s) b.speed -= b.accel;
                b.speed = Math.max(Math.min(b.speed, b.max), -b.max/2);
                b.speed *= b.fric;
                if(Math.abs(b.speed)>0.001) {
                    const dir = b.speed>0 ? 1:-1;
                    if(k.a) b.angle += b.turn * dir;
                    if(k.d) b.angle -= b.turn * dir;
                }
                b.vel.set(Math.sin(b.angle), 0, Math.cos(b.angle)).multiplyScalar(b.speed);
                const nextPos = this.objects.boat.position.clone().add(b.vel);
                const distFromCenter = nextPos.length();
                const inDockX = nextPos.x > -6 && nextPos.x < 6;
                const inDockZ = nextPos.z > 30 && nextPos.z < 62;
                if (distFromCenter < 35 || (inDockX && inDockZ)) { b.speed *= -0.5; } 
                else { this.objects.boat.position.add(b.vel); }
                this.objects.boat.rotation.y = b.angle;
                const turn = (k.d?-1:(k.a?1:0));
                this.objects.boat.rotation.z = THREE.MathUtils.lerp(this.objects.boat.rotation.z, turn*0.2*(Math.abs(b.speed)/b.max), 0.05);
                this.objects.boat.rotation.x = -b.speed*0.2;
                this.objects.boat.position.y = Math.sin(performance.now()*0.0015)*0.2;
                this.controls.target.copy(this.objects.boat.position);
                this.controls.update();
                const dist = this.objects.boat.position.distanceTo(new THREE.Vector3(0,0,50));
                const prompt = document.getElementById('npc-prompt');
                if(dist < 30 && !this.state.talking) { this.state.canTalk = true; prompt.style.display = 'flex'; } 
                else { this.state.canTalk = false; prompt.style.display = 'none'; }
            },

            startDialogue: function() {
                this.state.talking = true; this.physics.speed = 0;
                document.getElementById('npc-prompt').style.display = 'none';
                const target = this.objects.npc.position.clone().add(new THREE.Vector3(0,2,0));
                gsap.to(this.camera.position, {x:10, y:8, z:65, duration:1.5, ease:"power2.out"});
                gsap.to(this.controls.target, {x:target.x, y:target.y, z:target.z, duration:1.5});
                document.getElementById('rpg-ui').classList.add('active');
                this.runDialog('start');
            },

            runDialog: function(id) {
                const nodes = {
                    start: { t: "Who are you?", opts:[{l:"I'm a visitor.", n:'who'}, {l:"I want to explore the island.", n:'open'}] },
                    who: { t: "I'm Monkey D. Luffy! I'm gonna be King of the Pirates!", opts:[{l:"Cool!", n:'open'}, {l:"See ya.", n:'close'}] },
                    open: { t: "Shishishi! Go ahead! Explore the island!", act:'enter' },
                    close: { t: "See ya later!", act:'exit' }
                };
                const d = nodes[id];
                const txt = document.getElementById('rpg-text');
                const opts = document.getElementById('rpg-options');
                txt.textContent = ""; opts.innerHTML = "";
                let i=0;
                const t = setInterval(()=>{
                    txt.textContent += d.t[i]; i++;
                    if(i>=d.t.length) {
                        clearInterval(t);
                        if(d.opts) d.opts.forEach(o => {
                            const b = document.createElement('div');
                            b.className='rpg-btn'; b.innerText='> '+o.l;
                            b.onclick=()=>this.runDialog(o.n);
                            opts.appendChild(b);
                        });
                        else setTimeout(()=>d.act==='enter'?this.enterPort():this.endDialog(), 1000);
                    }
                }, 35);
            },

            endDialog: function() {
                document.getElementById('rpg-ui').classList.remove('active');
                this.state.talking = false;
                gsap.to(this.camera.position, {x:0, y:20, z:this.objects.boat.position.z+40, duration:1.5});
            },

            enterPort: function() {
                document.getElementById('rpg-ui').classList.remove('active');
                this.state.docked = true; this.controls.enabled = false;
                gsap.to(this.camera.position, {x:30, y:30, z:30, duration:2, ease:"power2.inOut"});
                gsap.to(this.controls.target, {x:0, y:20, z:0, duration:2});
                setTimeout(()=>document.getElementById('portfolio-modal').classList.add('active'), 1200);
            },

            closePortfolio: function() {
                document.getElementById('portfolio-modal').classList.remove('active');
                this.state.docked = false; this.state.talking = false; this.controls.enabled = true;
                this.physics.speed = -0.8;
                gsap.to(this.objects.boat.position, {z:80, duration:2});
                gsap.to(this.camera.position, {x:0, y:20, z:120, duration:2});
            },

            nav: function(id) {
                document.querySelectorAll('.section').forEach(e=>e.classList.remove('active'));
                document.getElementById('sec-'+id).classList.add('active');
                document.querySelectorAll('.p-nav').forEach(e=>e.classList.remove('active'));
                event.target.classList.add('active');
            },

            onResize: function() {
                this.camera.aspect = window.innerWidth/window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            },

            animate: function() {
                requestAnimationFrame(() => this.animate());
                const t = performance.now()*0.001;
                if(this.water) this.water.material.uniforms['time'].value += 1.0/60.0;
                
                this.updatePhysics(t);
                this.updatePirateShips(t); 
                this.animateHawk(t); 
                this.animateDolphins(t); 
                // REMOVED: this.animateWaterTornado(t); 

                // LIGHTNING SYSTEM
                if(this.state.night) {
                    // Random chance (approx every 5-10 seconds)
                    if(Math.random() < 0.003) { 
                        this.triggerLightning();
                    }
                }
                
                // Cleanup Bolts
                for(let i=this.objects.lightningBolts.length-1; i>=0; i--) {
                    const b = this.objects.lightningBolts[i];
                    b.age += 1;
                    b.mesh.material.opacity = 1 - (b.age / 10); // Fade out
                    b.mesh.material.transparent = true;
                    if(b.age > 10) {
                        this.scene.remove(b.mesh);
                        this.objects.lightningBolts.splice(i, 1);
                    }
                }

                if(this.objects.npc) {
                    this.objects.npc.rotation.y = Math.sin(t*0.5)*0.5; 
                    this.objects.npc.position.y = 2.5 + Math.sin(t*1.5)*0.5;
                    if(this.objects.npc.children[2]) this.objects.npc.children[2].position.y = 2.5 + Math.sin(t*3)*0.3;
                }

                if(this.objects.fireflies) {
                    this.objects.fireflies.position.copy(this.objects.boat.position);
                    this.objects.fireflies.position.y += 5;
                    const p = this.objects.fireflies.geometry.attributes.position.array;
                    for(let i=1; i<p.length; i+=3) p[i] += Math.sin(t*2+i)*0.05;
                    this.objects.fireflies.geometry.attributes.position.needsUpdate = true;
                }
                
                if(this.objects.lanterns) {
                    this.objects.lanterns.children.forEach(l => {
                        l.position.y = 0.5 + Math.sin(t * l.userData.speed + l.userData.offset) * 0.2;
                    });
                }
                
                if(this.objects.boat) {
                    const flag = this.objects.boat.getObjectByName("pirateFlag");
                    if(flag) flag.rotation.y = (Math.PI/2) + Math.sin(t * 5) * 0.2;
                }
                
                this.objects.supplyCrates.forEach(c => {
                    c.position.y = Math.sin(t + c.userData.offset)*0.3;
                    c.rotation.x = Math.sin(t*0.5 + c.userData.offset)*0.1;
                    c.rotation.z = Math.cos(t*0.3 + c.userData.offset)*0.1;
                    c.rotation.y += c.userData.rotSpeed;
                });

                // Whale Animation
                if(this.objects.whale) {
                    this.state.whaleState.t += 0.005;
                    const cycle = this.state.whaleState.t % 12;
                    if(cycle > 8) { 
                        const jumpT = (cycle - 8) / 4;
                        const y = Math.sin(jumpT * Math.PI) * 40 - 10;
                        const z = -20 - jumpT * 100; 
                        this.objects.whale.position.set(-50, y, z);
                        this.objects.whale.rotation.x = Math.PI/4 - jumpT * Math.PI/2;
                        
                        if(jumpT > 0.9 && !this.state.whaleState.splashed) {
                            this.createSplash(this.objects.whale.position);
                            this.state.whaleState.splashed = true;
                        }
                    } else {
                        this.state.whaleState.splashed = false;
                        this.objects.whale.position.y = -30;
                    }
                }

                for(let i = this.objects.explosions.length - 1; i >= 0; i--) {
                    const ex = this.objects.explosions[i];
                    ex.age += 0.015;
                    const pos = ex.mesh.geometry.attributes.position.array;
                    for(let j=0; j<ex.vels.length; j+=3) { 
                        pos[j] += ex.vels[j];
                        pos[j+1] += ex.vels[j+1];
                        pos[j+2] += ex.vels[j+2];
                        ex.vels[j+1] -= (ex.gravity || 0.01); 
                        if(ex.drag) {
                            ex.vels[j] *= ex.drag; ex.vels[j+1] *= ex.drag; ex.vels[j+2] *= ex.drag;
                        }
                    }
                    ex.mesh.geometry.attributes.position.needsUpdate = true;
                    ex.mesh.material.opacity = Math.max(0, 1 - ex.age);
                    if(ex.age >= 1) {
                        this.scene.remove(ex.mesh);
                        this.objects.explosions.splice(i, 1);
                    }
                }

                if(this.objects.boat && this.minimap.renderer && this.state.mapVisible) {
                    this.minimap.camera.position.x = this.objects.boat.position.x;
                    this.minimap.camera.position.z = this.objects.boat.position.z;
                    this.minimap.renderer.render(this.minimap.scene, this.minimap.camera);
                    const arrow = document.getElementById('minimap-arrow');
                    if(arrow) arrow.style.transform = `translate(-50%, -50%) rotate(${-this.objects.boat.rotation.y}rad)`;
                }

                this.renderer.render(this.scene, this.camera);
            }
        };

        Game.init();
    </script>
</body>
</html>